<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="Imputer" minver="2021d">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>0.1</version>
<date>2022-01-01</date>
<description>Impute missing values by some method</description>
<tags>C13 C52</tags>
<help>
TBA

For a more detailed manual, see &lt;https://github.com/atecon/PairPlot/blob/master/README.md&gt;.

Please report bugs or comments on the gretl mailing list or write to atecon@posteo.de.



Public function
===============

PairPlot(const list L, const series factor[null], bundle opts[null])
========
Parameters:
-----------
L        -- list, List of series to plot.
factor   -- series, Categorical (numeric or string-valued) variable for
            mapping plot aspects to different colors and/or points/ circles
            (optional, default: null).
opts     -- bundle, Optional bundle for passing additional parameters. See
            below for explanation (optional, default: null)


Returns:
--------
An integer of value '0' (FALSE) if no error occurs, otherwise 1 (TRUE).



Changelog:
----------
Version 0.1 (December 2021):
  - Initial version
</help>
<depends count="2">
PanelTools extra </depends>
<provider>PanelTools</provider>
<gretl-function name="impute" type="series">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="method" type="string" const="true"/>
 </params>
<code>/* Public function for imputing missing values of 'y' by some 'method'.
return: series, imputed series. */
string datatype = $datatype == 3 ? &quot;panel&quot; : &quot;else&quot;
# Get mapped function parameters - also depends on datatype
bundle Func = method_to_function_map(method)[&quot;@datatype&quot;]
if Func.dtype == &quot;series&quot;
  series ret = missing(y) ? feval(Func.method, y) : y
else
  funcerr &quot;Case not covered, yet.&quot;
endif
return ret
</code>
</gretl-function>
<gretl-function name="method_to_function_map" type="bundle" private="1">
 <params count="1">
  <param name="method" type="string" const="true"/>
 </params>
<code>/* Mapping method to function name being called.
return: string, Function name being called. */
bundle Map = null
Map.min = _( panel = _(method = &quot;pmin&quot;, dtype = &quot;series&quot;), else = _(method = &quot;min&quot;, dtype = &quot;series&quot;) )
Map.max = _( panel = _(method = &quot;pmax&quot;, dtype = &quot;series&quot;), else = _(method = &quot;max&quot;, dtype = &quot;series&quot;) )
Map.mean = _( panel = _(method = &quot;pmean&quot;, dtype = &quot;series&quot;), else = _(method = &quot;mean&quot;, dtype = &quot;series&quot;) )
Map.median = _( panel = _(method = &quot;pmedian&quot;, dtype = &quot;series&quot;), else = _(method = &quot;median&quot;, dtype = &quot;series&quot;) )
Map.cum = _( panel = _(method = &quot;pcum&quot;, dtype = &quot;series&quot;), else = _(method = &quot;cum&quot;, dtype = &quot;series&quot;) )
Map.mode = _( panel = _(method = &quot;mode&quot;, dtype = &quot;series&quot;), else = _(method = &quot;mode&quot;, dtype = &quot;series&quot;) )
Map.first = _( panel = _(method = &quot;first&quot;, dtype = &quot;series&quot;), else = _(method = &quot;first&quot;, dtype = &quot;series&quot;) )
Map.last = _( panel = _(method = &quot;last&quot;, dtype = &quot;series&quot;), else = _(method = &quot;last&quot;, dtype = &quot;series&quot;) )
return Map[&quot;@method&quot;]
</code>
</gretl-function>
<gretl-function name="get_number_of_cross_units" type="scalar" private="1">
<code>/* Return number of cross-sectional units. In case of time-series and cross-sectional data, set N = 1.
return: int, number of cross-sectional units. */
return $datatype == 3 ? ($nobs / $pd) : 1
</code>
</gretl-function>
<gretl-function name="get_number_of_time_periods" type="scalar" private="1">
<code>/* Return number of time-periods. In case of cross-sectional data, T=1.
return: int, number of time-periods. */
if $datatype == 1
  return 1
elif $datatype == 2
  return $nobs
elif $datatype == 3
  return $pd
else
  funcerr(&quot;Data type not supported.&quot;)
endif
</code>
</gretl-function>
<gretl-function name="mode" type="series" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute most frequent value for each cross-sectional unit.
return: series, constant value for each cross-sectional unit.
Dependency: extra.gfn */
errorif(!nobs(y), &quot;No valid observations.&quot;)
set skip_missing off
scalar N = get_number_of_cross_units()
scalar T = get_number_of_time_periods()
matrix m = mshape({y}, T, N)
matrix mat = mshape(NA, N, 1)
loop i=1..N
  mat[i] = onemode(m[,i])[1]
endloop
set skip_missing on
series ret = $datatype == 3 ? pexpand(mat) : mat
string desc = get_description(&quot;mode&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="helper_first_last" type="series" private="1">
 <params count="2">
  <param name="y" type="series" const="true"/>
  <param name="do_last" type="bool" const="true"/>
 </params>
<code>/* Wrapper for first() and last()
return: series, respective values. */
set skip_missing off
scalar N = get_number_of_cross_units()
scalar T = get_number_of_time_periods()
matrix m = mshape({y}, T, N)
matrix ret = mshape(NA, N, 1)
loop i=1..N
  matrix mask = ok(m[,i])
  matrix vals = selifr(m[,i], mask)
  scalar idx = do_last == TRUE ? rows(vals) : 1
  ret[i] = sum(mask) ? vals[idx] : NA
endloop
set skip_missing on
return $datatype == 3 ? pexpand(ret) : ret
</code>
</gretl-function>
<gretl-function name="first" type="series" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute first valid value for each panel unit. Expand this constant value for each unit to a series. */
series ret = helper_first_last(y, FALSE)
string desc = get_description(&quot;first&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<gretl-function name="last" type="series" private="1">
 <params count="1">
  <param name="y" type="series" const="true"/>
 </params>
<code>/* Compute last valid value for each panel unit. Expand this constant value for each unit to a series. */
series ret = helper_first_last(y, TRUE)
string desc = get_description(&quot;last&quot;, argname(y), -1)
setinfo ret --description=&quot;@desc&quot;
return ret
</code>
</gretl-function>
<sample-script>

</sample-script>
</gretl-function-package>
</gretl-functions>
